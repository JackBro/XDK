/*
 * Copyright (c) 2008-2016, Integrity Project Ltd. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the Integrity Project nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE
 */

#ifndef __TBA_XDK_EHLIB_EHLIB_H
#define __TBA_XDK_EHLIB_EHLIB_H

/*
 * ehlib.h
 *
 * The data-structs needed for exception-handling for Microsoft visual C++ 6.0
 * The functions prototype which implement the compiler complex mechanism.
 *
 * Author: Elad Raz <e@eladraz.com>
 */
#include "xStl/types.h"

// The EHLib can operate on both Windows Ring3 application and Rin0 drivers
// platforms.
#ifdef _KERNEL
    #include "xdk/kernel.h"
    #include "xdk/utils/interruptSpinLock.h"
#else
    #include <windows.h>
#endif

// Other include files
#include "xStl/data/hash.h"
#include "xStl/data/char.h"
#include "xStl/data/string.h"
#include "xStl/os/mutex.h"
#include <typeinfo.h>

/*
 * Types, structs, return-values that generated by the compiler in order to
 * describe the objects, exception blocks for a function.
 * When a exception is thrown, the destructors should be called, the stack
 * should revert to the exception handling state.
 *
 * Most of the structs are reversed enginnered.
 *
 * The following compiler flags should be enable for all other libraries
 * but NOT for xdk_ehlib library:
 *   /GX  - Enable exception handling (Turn on C++ exception handling)
 *   /EHa - Allow synchouniuse exception handling. Exception can be thrown
 *          any-where in the code.
 */
class EHLib
{
public:

    ///////////////////////
    // Public functions

    #ifndef EHLIB_STATIC
    /*
     * This function should be called withing a 'catch' section.
     *
     * The function returns a string which matches the current exception run-time
     * information.
     *
     * If the exception is OS exception, the return string will be the NTSTATUS
     * describing the exception
     *
     * If the current block is not within a catch block the function returns
     * the 'm_noException' string
     */
    static cString getUnknownException();
    #endif // EHLIB_STATIC

    // The string that returns in the 'getUnknownException' if the block is not
    // a catch block
    static const character m_noException[];

    ///////////////////////
    // Enums

    /*
     * When a C++ exception is called the EHLib addes to the exception code
     * few filleds in order to descrives the run time information of the
     * exception and the exception object.
     *
     * These enum defines where the data of the exception is stored inside the
     * ExceptionRecord.ExceptionInforamtion block.
     */
    enum
    {
        // The numberof arguments passed as "Information" to the exception-record
        NUMBER_OF_EXCEPTION_ARGUMENTS = 3,
        // The exception object
        EXCEPTION_ARGUMENT_CONTEXT  = 0,
        // The exception run time information
        EXCEPTION_ARGUMENT_RTTI     = 1,
        // The magic postion
        EXCEPTION_ARGUMENT_MAGIC    = 2
    };

    /*
     * Try-level none. The object is not inside any try-catch block and doesn't
     * contains any dependency.
     */
    enum
    {
        TRY_LEVEL_NONE = 0xFFFFFFFF
    };

    /*
     * The 'ExceptionRecord.ExceptionFlags' flags
     * The flags are used to distinguish the unwinding mode and first handler
     * execuation.
     */
    enum
    {
        // The exception cannot be continued (Using ExceptionContinueExecuation)
        EH_NONCONTINUABLE = 1,
        // The state of the exception is unwinding
        EH_UNWINDING      = 2,
        // The state of the exception is stop unwinding
        EH_EXIT_UNWIND    = 4,
        // All types of exception unwind.
        EH_UNWIND_MODE    = EH_UNWINDING | EH_EXIT_UNWIND
    };

    /*
     * The magic number which are in used in the struct exception code.
     */
    enum
    {
        /// The magic of the EHLIB (TBA_)
        EHLIB_EXCEPTION_CODE = 0x0E414254,
        /// The magic for Blue-Screen exception (TB1_)
        BLUESCREEN_EXCEPTION_CODE = 0x0E314254
    };

    ///////////////////////
    // Structs

    /*
     * Run-time descriptor of a catch block.
     *
     * See CatchDescriptor for more information
     */
    struct CatchRTTI
    {
        // Unknown
        uint32 m_unknown;
        // The type_info of what the exception cat eat
        type_info* m_rttiDescriptor;
        // A stack pointer where the exception context should be put.
        uint32 m_spoof;
        /*
         * The catch exception handling code.
         * Return a linear address where the code flow should resume.
         */
        uint32 (__cdecl *m_proc)(void);
    };

    /*
     * A single entry inside the exception tree. The entry contains a 'proc'
     * which execute destructor code and ID which locate the entry inside the
     * exception tree.
     */
    struct ExceptionDtorFunction
    {
        /*
         * The ID of the entry. The ID locate the entry inside the exception-
         * handling blocks for a function.
         * This variable and the try-level have the knowledge to deciede whether
         * the object should be called.
         *
         * See FunctionEHData for more information about the tree
         */
        uint32 m_id;

        /*
         * Pointer into a function which execute a destructor. Most of the code
         * in the function is as follows:
         *    mov ecx,[ebp-Object]
         *    jmp ObjectType::~ObjectTyped
         *
         * This number can be NULL, which spesify a division inside the try-level
         * tree.
         */
        void (_cdecl *m_proc)(void);
    };


    /*
     * A single try-catch entry descriptor. Describes the context of the exception
     * handling (The range) and which exception can be handles inside the block.
     *
     * See FunctionEHData for more information about the tree
     */
    struct CatchDescriptor
    {
        // The start tryLevel which the block resposiable for
        uint32 m_startTryLevel;
        // The end tryLevel which the block resposiable for
        uint32 m_endTryLevel;
        // TODO! The tryLevel for the objects inside the catch handlers.
        uint32 m_endTryLevel1;
        /*
         * The number of different catch types.
         * For example:
         *   try {
         *   } catch (Exception& e) {
         *   } catch (...) {
         *   }
         * Has 2 catch blocks and the m_rtti will be point to:
         *   - .A?Exception@  ->  .A?AssertionException (Can eat class type AssertionException)
         *                        .A?FileException@  (Can eat class type FileException)
         *                        .A?IOException@  (Can eat class type IOException)
         *                        .A?Exception@  (Can eat class type Exception)
         *   - 00000000       -> Can eat all types of exceptions
         */
        uint32 m_catchCount;
        // The run-time information for the catch block
        CatchRTTI* m_rtti;
    };

    /*
     * The main-data struct which the compiler generate per a function. The tree
     * contains a tree which represnt the try-catch blocks in the function and
     * all constructed objects.
     *
     * Each function contains a stack-variable named 'tryLevel' which point into
     * the last location inside the function. The tryLevel is the first variable
     * in the local stack argument [ebp-4]
     *
     * Here are a few examples of codes and thier generated trees.
     * 1. void normal()
     *    {
     *        ObjectType A,B,C;
     *    }
     *    Will translate into the following tree:
     *    objectsDtor -> Index    ID           PROC
     *                   -----    --           ----
     *                   0        FFFFFFFF     A::~A
     *                   2        00000001     B::~B
     *                   3        00000002     C::~C
     *    catchBlocks -> NULL (There aren't any try-catch blocks)
     *
     * 2. void tryBlock()
     *    {
     *        try
     *        {
     *             doExceptions();
     *        }
     *        catch (...)
     *        {
     *        }
     *    }
     *    Will translate into the following tree:
     *    objectsDtor -> NULL
     *    catchBlocks -> startTryLevel  FFFFFFFF
     *                   endTryLevel    FFFFFFFF
     *                   catchCount: 1
     *                         rtti     NULL (catch all ...)
     *                         spoof    0
     *                         ehCode   &tryBlock::catch(...)
     *
     * TODO! more examples!
     */
    enum { FRAME_HANDLER_TYPE_0 = 0x19930520 };
    enum { FRAME_HANDLER_TYPE_3 = 0x19930522 };

    struct FunctionEHData
    {
        // The magic which describes MSVC6.0 compiler,
        // should be equal to 19930520h
        // Visual Studio 10 and Visual Studio 8 use this structure for exceptions
        // should be equal to 19930522h
        uint32 m_magic;
        // The number of object destructors in the 'm_objectsDtor'
        uint32 m_countObjectsDtor;
        // A list at size 'm_countObjectsDtor' which represents the object tree
        ExceptionDtorFunction* m_objectsDtor;
        // The size of 'm_catchBlocks'
        uint32 m_countCatchBlocks;
        // The number of try-catch blocks for a function
        CatchDescriptor* m_catchBlocks;
    };

    // The ExceptionRecord
    typedef struct _EXCEPTION_RECORD ExceptionRecord;

    // Some forward declartions
    struct MSCPPEstablisher;

    /*
     * The exception handler frame-handler prototype.
     * See EHLib::internalFrameHandler for more information.
     */
    typedef EXCEPTION_DISPOSITION (__cdecl *FrameHandlerFunc)(
        EHLib::ExceptionRecord* exceptionRecord,
        EHLib::MSCPPEstablisher* establisherFrame,
        struct _CONTEXT* contextRecord,
        struct _CONTEXT** dispatcherContext);

    /*
     * The operating system SEH block for microsoft visual C++ 6.0 exception
     * handling descriptor.
     * The FS register is point to:
     *    - previousHandler  -> The old FS chain
     *    - handler          -> The execute code in case of exception
     *
     * The C++ exception handling add to this struct (Like the scopetable,
     * try-filters of C SEH code) the following:
     *  - TryLevels  -> The first local argument, the position inside the tryLevel
     *                  tree. See FunctionEHData for tree information.
     *  - oldEbp     -> The base of the previous stack.
     */
    struct MSCPPEstablisher
    {
        // The old FS struct. The chain descriptor.
        MSCPPEstablisher* m_previousHandler;
        // The code for the exception handling
        FrameHandlerFunc m_exceptionHandler;
        // The tryLevel
        uint32 m_tryLevel;
        // The old base-pointer register
        uint32 m_oldEbp;
    };

    /*
     * A wrapper around the type_info class
     */
    struct type_info1
    {
        // Unknown
        uint32 m_unknown;
        // The type_info class
        type_info* m_typeInfo;
    };

    /*
     * The run-time information. For each class stores it's name and
     * it's supper name.
     * For example:
     *   FileException will represnt as:
     *       .A?FileException@  <=> FileException
     *       .A?IOException@    <=> IOException
     *       .A?Exception@      <=> Exception
     */
    struct ExceptionRunTimeInformation
    {
        // The number of super-class
        uint32 m_count;
        // The type-info array
        type_info1* m_types[1];
    };

    /*
     * The run-time information that pass when a C++ exception is thrown
     */
    struct ExceptionTypeInformation
    {
        // Unknown
        uint32 m_unkown;
        // A C++ function (ECX) which destruct the exception
        void* m_destructor;
        // Unknown
        uint32 m_unknown1;
        // Exception run-time information
        ExceptionRunTimeInformation* m_rtti;
    };

    ///////////////////////
    // Functions

    /*
     * The frame handler is a generic function which called whenever an
     * exception occuered in a context of the current running function or
     * at the unwinding functions.
     * The exception types which this function is called at are C++ exception
     * which throw using the C++ "throw" operator or SEH exception which are
     * traps captured by the operating system. This traps are interrupt sush as
     * "Access violation" C0000005, Dividing by zero and more...
     *
     * exceptionRecord - The exception frame. Contains the code for the exception,
     *                   it's location, the program-counter and few more arguments
     * establishFrame  - The beginning stack frame from the fs:[0].
     * contextRecord   - The context of the current running thread
     * dispatcherContext - The output context.
     * eh              - The exception-handling blocks descriptors.
     *
     * Return the handling for the exception.
     *   The return code is usually: ExceptionContinueSearch which tells the OS
     *        to revert the stack back to the previous handling funciton blocks.
     *   When the exception is handled the flow of the application is chopped
     *   and the function never returned.
     */
    static EXCEPTION_DISPOSITION internalFrameHandler(
        ExceptionRecord*  exceptionRecord,
        MSCPPEstablisher* establisherFrame,
        struct _CONTEXT*  contextRecord,
        struct _CONTEXT** dispatcherContext,
        FunctionEHData*   eh,
        uint level);

    /*
     * Called in order to throw a C++ exception.
     *
     * objectContext     - Pointer to the instance of the C++ class
     * objectType        - The run-time information for the object class.
     * exceptionLocation - The program-counter which throws the C++ exception
     *
     * The function never returned! The flow of the application is altered.
     */
    static void internalThrowException(void* objectContext,
                                       ExceptionTypeInformation* objectType,
                                       void* exceptionLocation);

    #ifdef _DEBUG
    /*
     * Flags the exception handling library to start debugging itself.
     *
     * This function used internally and only in order to find bugs in the EHLib
     * system.
     *
     * Don't use this function unless you control all EHLib internals.
     */
    static void markExceptionDebugging();
    #endif

    /*
     * Reset the exception-handling list.
     *
     * Return the head-pointer of the previous exception-handling list.
     * See restoreExceptionList
     */
    static void* resetExceptionHandlingList();

    /*
     * Restore an exception-handling list
     *
     * list - The exception-handling list to be restored.
     */
    static void restoreExceptionList(void* list);

    //////////////////////////////////////////////
    // Private functions and structs used for the
    // 'EhlibRaiseException' implementation

    struct NtThreadInformationBlock {
        // The first establisher frame pointer
        MSCPPEstablisher* exceptionListHead;
        // The current stack base. This variable must be higher than 'stackLimit'
        addressNumericValue stackBase;
        // The limits of the stack
        addressNumericValue stackLimit;
    };

    /*
    * Returns the current thread information block
    */
    static NtThreadInformationBlock getCurrentThreadInformationBlock();

private:
    /*
     * The data needed per thread in order to save the exception information.
     */
    class ExceptionThreadBlock
    {
    public:
        // Default constructor.
        ExceptionThreadBlock();

        // Copy-constructor and operator = will automatic generated.

        // The last exception-record
        ExceptionRecord m_exceptionRecord;
        // The last exception-record information. NULL means an OS exception.
        ExceptionTypeInformation* m_exceptionType;
        // The last exception context
        void* m_exceptionObject;
    };

    // The thread-ID. Return by the PsGetCurrentThread() function
    // NOTE: This variable is different than the xStl::OS library since this
    // lib night be exported to outside sources...
    typedef addressNumericValue ThreadID;

    // Special return code for the matchCatchBlock which indicate that any of the
    // catch handlers cannot handles the exception
    enum { MISS_CATCH_BLOCK = 0xFFFFFFFF };

    /////////////////////////////
    // Private functions

    // The XDK inits the exception-handling library
    friend class cXDKLibCPP;
    // The exception-handling vector destructor. See EHlibcpp.h
    friend void __stdcall arrayUnwind(uint8* objectArray,
                                      uint   objectSize,
                                      int    elementsCount,
                                      void*  destructor);
    // The exception-handling vector constructor. See EHlibcpp.h
    friend void __stdcall ec(void*  objectArray,
                             uint   objectSize,
                             int    elementsCount,
                             void (__stdcall *constructor)(void*),
                             void (__stdcall *destructor)(void*));


    /*
     * Constructor. Init the exception-handling context and optimize the
     * performances.
     */
    EHLib();

    /*
     * Initialize the EHlib for use.
     * Called as the first function in the XDK-initialize.
     * Blue screen, if the instance is exist.
     */
    #ifdef EHLIB_STATIC
       // For testing application, the create instance is a global function
       public:
    #endif // EHLIB_STATIC
    static void createInstance();

    /*
     * Return the instance of the EHlib.
     *
     * Blue-screen the system if the createInstance() wouldn't be called.
     */
    static EHLib& getInstance();

    /*
     * Free the EHlib.
     * Called as the last function in the driver
     * Blue screen, if the instance is not exist.
     */
    static void destroyInstance();

    /*
     * Return the current running thread-ID
     */
    static ThreadID getCurrentThreadID();

    /*
     * The function calculates the base-pointer (EBP) of the stack according to the
     * establisher-frame.
     *
     * establisherFrame - The function establisher-frame. Generated by the compiler
     *                    and stored at the FS register
     */
    static uint32* getStackBasePointer(MSCPPEstablisher* establisherFrame);

    /*
     * Execute a function of prototype vois*(*)(void) (Catch handler has the same
     * prototype.) in the context of a spesify establisher-frame.
     *
     * If the function is NULL the function is simpliy return NULL.
     *
     * establisherFrame - The stack frame. Used to calculate the base of the stack
     *                    for the spesify function.
     * proc             - The address for the function.
     *
     * Return the return code (EAX register) of the function.
     * For catch-handler this return code is the continue flow entry of the program
     */
    static void* executeProc(MSCPPEstablisher* establisherFrame,
                             void* proc);

    /*
     * Enumerates over the RTTI of the exception and all catch handler and
     * try to find the first catch-handler which can handle the exception.
     * If the exception is a C++ exception and the handler is also a C++
     * exception (Not a catch(...) handler), the function fixes the handler
     * stack to point over the exception-object.
     *
     * establisherFrame - The stack frame.
     * catchBlocks      - List of all try-catch block handlers
     * exceptionType    - The run-time information for the exception object.
     *                    If the exception is an OS exception (such as access
     *                    violation - C0000005) then this argument should be
     *                    NULL and the exceptionObject will be ignored.
     * exceptionObject  - The instance exception object
     *
     * Return the location of the catch to be execute or MISS_CATCH_BLOCK
     * which indicate that neither of the handlers matchs the exceptions.
     */
    static uint matchCatchBlock(MSCPPEstablisher* establisherFrame,
                                CatchDescriptor* catchBlocks,
                                ExceptionTypeInformation* exceptionType,
                                void* exceptionObject);

    /*
     * Safe execute a C++ method of prototype void (*)(void).
     * Constructors and destructors are function which can be executed using
     * this function.
     *
     * object - The object instance
     * proc   - Pointer to the code to be executed
     *
     * Return true if the function executed or false if any exceptions occurred
     * in the middle of the execution.
     */
    static bool callCppMethod(void* object,
                              void* proc);

    /*
     * Change the flow of the program back from the exception handling to
     * the coninue of the normal application.
     * Revert the local stack (EBP, ESP register) and change the flow.
     *
     * establisherFrame - The stack frame.
     * continueAddress  - Pointer to the code to be continue execution from.
     *
     * This function is never returned.
     */
    static void continueExecuation(MSCPPEstablisher* establisherFrame,
                                   void* continueAddress);

    /*
     * Destruct the stack objects from the current try-level to the 'revertTryLevel'
     * and revert the stack to that point.
     * Only the constructed objects and the objects which are relevant to the try-
     * levels from the current to the reverted stack will be destructed.
     *
     * For more information about try-level and how this function knows which objects
     * should be destructed, see the tree desciptor at the FunctionEHData class.
     *
     * establisherFrame - The stack frame.
     * eh               - The exception-handling blocks descriptors.
     * revertTryLevel   - The try-level to revert to.
     */
    static void destructTryBlockStack(MSCPPEstablisher* establisherFrame,
                                      FunctionEHData* eh,
                                      uint32 revertTryLevel);

    /*
     * Calculate the start try-catch block which belongs to the current exception.
     * The function compare the current function try-level state with the list
     * of try-catch blocks for this function.
     *
     * For more information about try-level and how this function knows which objects
     * should be destructed, see the tree desciptor at the FunctionEHData class.
     *
     * establisherFrame - The stack frame.
     * eh               - The exception-handling blocks descriptors.
     *
     * Return TRY_LEVEL_NONE if there isn't try-block for this function.
     */
    static uint getTryCatchBlock(MSCPPEstablisher* establisherFrame,
                                 FunctionEHData* eh);

    /*
     * Safely (Interrupt-locked, thread-lock, multi-processor-lock) copy a
     * thread running exception information into a stack-variable (etb).
     *
     * id           - The thread identification
     * etb          - Will be filled with current exception-thread-block
     * shouldRemove - Set to true in order to poll the exception from the system
     *
     * Return true if the current thread has exception-block and it's copy to
     * the stack variable, false otherwise
     */
    static bool copyThreadException(const ThreadID& id,
                                           ExceptionThreadBlock& etb,
                                           bool shouldRemove = false);

    /*
     * Dismiss the exception-record from the current thread.
     */
    static void freeCurrentThreadException();

    /*
     * Stores a new exception for the current thread
     *
     * exception - The exception to be stored
     */
    static void storeNewThreadException(const ExceptionThreadBlock& exception);

    /////////////////////////////////////
    // Operating system simulation API
    // NEW!
    // This function are compiled only if
    #ifdef EHLIB_SPECIAL_EXCEPTIONS
    /*
     * Simulates the kernel RtlRaiseException function. Raise the exception and
     * throw it directly to the exception handling machinize.
     * Since this function is used internally by drivers, the thread status
     * variables, such as: IRQL, PreviousMode and so one... doesn't take in
     * consideration.
     *
     * exceptionRecord - The exception to be raise
     */
    static void EhlibRaiseException(ExceptionRecord* exceptionRecord);

    /*
     * Revert the exception-handling stack back to establisherFrame pointer
     *
     * establisherFrame - The exception handling node which handle the exception
     */
    static void EhlibUnwind(MSCPPEstablisher* establisherFrame);

    #endif // EHLIB_SPECIAL_EXCEPTIONS

    /////////////////////////////
    // Private members

    // The avegrage number of different threads. Used for optimize ETC (Exception)
    // Thread context
    enum { NORMAL_SYSTEM_THREADS = 120 };

    #ifdef EHLIB_STATIC
        // SingleThreaded
        bool m_isExceptionContext;
        ExceptionThreadBlock m_exceptionContext;
    #else
        /*
         * This hash-table translate between thread-handles and thier exception
         * content.
         * The hash table should be locked since it can be access from different threads
         */
        #ifdef XSTL_NTDDK
            cInterruptSpinLock
        #else
            cMutex
        #endif
                m_exceptionThreadContextMutex;
        cHash<ThreadID, ExceptionThreadBlock> m_exceptionThreadContext;
    #endif // EHLIB_STATIC

    #ifdef _DEBUG
    // The flag which the 'markExceptionDebugging()' function raise
    static bool DEBUGGED;
    #endif

    // The gloabl EHlib instance
    static EHLib* m_instance;
};

/*
 * Exported function from the NTDDK.lib
 * Revert the FS register to pointed to the previous stack-handler.
 * Used in SEH exception as well.
 */
EXTERNC void __cdecl _global_unwind2(void* establisherFrame);

#endif // __TBA_XDK_EHLIB_EHLIB_H
